---
description: Testing philosophy, tools, and patterns
globs:
  - "**/*.{test,spec}.{ts,tsx}"
  - "**/__tests__/**"
---

# Testing Strategy

> **Template**: Customize for your testing approach

---

## Testing Philosophy

### The Testing Pyramid

```
          ┌─────────┐
         /   E2E    \        Few, slow, high confidence
        /─────────────\
       /  Integration  \     Some, medium speed
      /─────────────────\
     /       Unit        \   Many, fast, focused
    /─────────────────────\
```

### Testing Principles

1. **Test behavior, not implementation**
2. **Write tests that give confidence**
3. **Prefer integration tests for features**
4. **Unit test complex logic**
5. **E2E for critical user journeys only**

---

## Tool Selection

| Purpose | Tool | When to Use |
|---------|------|-------------|
| **Unit/Integration** | [Vitest/Jest] | Business logic, hooks, components |
| **Component Visual** | [Storybook] | UI development, visual states |
| **E2E** | [Playwright/Cypress] | Critical user flows |
| **API Testing** | [MSW] | Mock API responses |

---

## Unit Testing

### What to Unit Test

- ✅ Utility functions
- ✅ Business logic
- ✅ Data transformations
- ✅ Validation logic
- ❌ Simple components (use integration)
- ❌ Framework code

### Example: Utility Function

```typescript
// utils/format.ts
export function formatCurrency(amount: number, currency = 'USD'): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency,
  }).format(amount)
}

// utils/format.test.ts
import { describe, it, expect } from 'vitest'
import { formatCurrency } from './format'

describe('formatCurrency', () => {
  it('formats USD by default', () => {
    expect(formatCurrency(1234.56)).toBe('$1,234.56')
  })
  
  it('formats other currencies', () => {
    expect(formatCurrency(1234.56, 'EUR')).toBe('€1,234.56')
  })
  
  it('handles zero', () => {
    expect(formatCurrency(0)).toBe('$0.00')
  })
  
  it('handles negative numbers', () => {
    expect(formatCurrency(-50)).toBe('-$50.00')
  })
})
```

---

## Component Testing

### What to Test

- ✅ User interactions
- ✅ Conditional rendering
- ✅ Form submissions
- ✅ Error states
- ❌ Internal state
- ❌ Implementation details

### Example: Component Test

```typescript
import { render, screen, userEvent } from '@testing-library/react'
import { describe, it, expect, vi } from 'vitest'
import { LoginForm } from './LoginForm'

describe('LoginForm', () => {
  it('submits form with valid data', async () => {
    const onSubmit = vi.fn()
    const user = userEvent.setup()
    
    render(<LoginForm onSubmit={onSubmit} />)
    
    await user.type(screen.getByLabelText(/email/i), 'test@example.com')
    await user.type(screen.getByLabelText(/password/i), 'password123')
    await user.click(screen.getByRole('button', { name: /login/i }))
    
    expect(onSubmit).toHaveBeenCalledWith({
      email: 'test@example.com',
      password: 'password123',
    })
  })
  
  it('shows validation errors', async () => {
    const user = userEvent.setup()
    
    render(<LoginForm onSubmit={vi.fn()} />)
    
    await user.click(screen.getByRole('button', { name: /login/i }))
    
    expect(screen.getByText(/email is required/i)).toBeInTheDocument()
  })
  
  it('disables button while submitting', async () => {
    render(<LoginForm onSubmit={vi.fn()} isSubmitting />)
    
    expect(screen.getByRole('button')).toBeDisabled()
  })
})
```

---

## Hook Testing

### Example: Custom Hook

```typescript
import { renderHook, waitFor } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { describe, it, expect, vi } from 'vitest'
import { useUser } from './useUser'

const wrapper = ({ children }) => (
  <QueryClientProvider client={new QueryClient()}>
    {children}
  </QueryClientProvider>
)

describe('useUser', () => {
  it('fetches user data', async () => {
    vi.mocked(api.getUser).mockResolvedValue({ id: '1', name: 'John' })
    
    const { result } = renderHook(() => useUser('1'), { wrapper })
    
    await waitFor(() => {
      expect(result.current.data).toEqual({ id: '1', name: 'John' })
    })
  })
  
  it('handles errors', async () => {
    vi.mocked(api.getUser).mockRejectedValue(new Error('Not found'))
    
    const { result } = renderHook(() => useUser('999'), { wrapper })
    
    await waitFor(() => {
      expect(result.current.error).toBeTruthy()
    })
  })
})
```

---

## Integration Testing

### Testing Full Features

```typescript
import { render, screen, userEvent, within } from '@testing-library/react'
import { describe, it, expect } from 'vitest'
import { server } from '@/mocks/server'
import { http, HttpResponse } from 'msw'
import { UserList } from './UserList'
import { TestProviders } from '@/test/utils'

describe('UserList Integration', () => {
  it('displays users and allows filtering', async () => {
    const user = userEvent.setup()
    
    render(
      <TestProviders>
        <UserList />
      </TestProviders>
    )
    
    // Wait for data to load
    expect(await screen.findByText('John Doe')).toBeInTheDocument()
    expect(screen.getByText('Jane Smith')).toBeInTheDocument()
    
    // Filter users
    await user.type(screen.getByPlaceholderText(/search/i), 'John')
    
    expect(screen.getByText('John Doe')).toBeInTheDocument()
    expect(screen.queryByText('Jane Smith')).not.toBeInTheDocument()
  })
  
  it('handles API errors gracefully', async () => {
    server.use(
      http.get('/api/users', () => {
        return HttpResponse.json(
          { error: 'Server error' },
          { status: 500 }
        )
      })
    )
    
    render(
      <TestProviders>
        <UserList />
      </TestProviders>
    )
    
    expect(await screen.findByText(/failed to load/i)).toBeInTheDocument()
  })
})
```

---

## E2E Testing

### When to Write E2E Tests

- ✅ Critical user journeys (login, checkout)
- ✅ Complex multi-page flows
- ✅ Payment/financial flows
- ❌ Every feature (too slow)
- ❌ Unit-testable logic

### Example: Playwright Test

```typescript
import { test, expect } from '@playwright/test'

test.describe('Authentication Flow', () => {
  test('user can login and access dashboard', async ({ page }) => {
    await page.goto('/login')
    
    await page.fill('[name="email"]', 'test@example.com')
    await page.fill('[name="password"]', 'password123')
    await page.click('button[type="submit"]')
    
    // Should redirect to dashboard
    await expect(page).toHaveURL('/dashboard')
    await expect(page.locator('h1')).toContainText('Welcome')
  })
  
  test('shows error for invalid credentials', async ({ page }) => {
    await page.goto('/login')
    
    await page.fill('[name="email"]', 'wrong@example.com')
    await page.fill('[name="password"]', 'wrongpassword')
    await page.click('button[type="submit"]')
    
    await expect(page.locator('[role="alert"]')).toContainText('Invalid credentials')
  })
})
```

---

## Mocking

### MSW Setup

```typescript
// mocks/handlers.ts
import { http, HttpResponse } from 'msw'

export const handlers = [
  http.get('/api/users', () => {
    return HttpResponse.json([
      { id: '1', name: 'John Doe' },
      { id: '2', name: 'Jane Smith' },
    ])
  }),
  
  http.post('/api/login', async ({ request }) => {
    const body = await request.json()
    
    if (body.email === 'test@example.com') {
      return HttpResponse.json({ token: 'mock-token' })
    }
    
    return HttpResponse.json(
      { error: 'Invalid credentials' },
      { status: 401 }
    )
  }),
]

// mocks/server.ts
import { setupServer } from 'msw/node'
import { handlers } from './handlers'

export const server = setupServer(...handlers)

// test/setup.ts
beforeAll(() => server.listen())
afterEach(() => server.resetHandlers())
afterAll(() => server.close())
```

---

## Test Organization

### File Structure

```
feature/
├── components/
│   ├── UserCard.tsx
│   └── UserCard.test.tsx     # Component test
├── hooks/
│   ├── useUsers.ts
│   └── useUsers.test.ts      # Hook test
├── utils/
│   ├── userHelpers.ts
│   └── userHelpers.test.ts   # Unit test
└── __tests__/
    └── UserList.integration.test.tsx  # Integration test
```

### Naming Conventions

| Type | Pattern | Example |
|------|---------|---------|
| Unit test | `*.test.ts` | `format.test.ts` |
| Component test | `*.test.tsx` | `Button.test.tsx` |
| Integration | `*.integration.test.ts` | `UserFlow.integration.test.ts` |
| E2E | `*.spec.ts` | `auth.spec.ts` |

---

## Test Utilities

### Custom Render

```typescript
// test/utils.tsx
import { render } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

const createTestQueryClient = () =>
  new QueryClient({
    defaultOptions: {
      queries: { retry: false },
    },
  })

export function renderWithProviders(ui: React.ReactElement) {
  const queryClient = createTestQueryClient()
  
  return render(
    <QueryClientProvider client={queryClient}>
      {ui}
    </QueryClientProvider>
  )
}

export * from '@testing-library/react'
export { renderWithProviders as render }
```

---

## Related Rules

- `coding-patterns.mdc` - Code conventions
- `state-management.mdc` - Testing state

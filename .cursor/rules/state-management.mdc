---
description: State management patterns and data fetching strategies
globs:
  - "**/*.{ts,tsx}"
---

# State Management Guide

> **Template**: Customize for your state management approach

---

## Decision Framework

### When to Use What

| State Type | Solution | Example |
|------------|----------|---------|
| **Server data** | React Query / SWR | User list, API data |
| **Local UI** | useState | Modal open, form input |
| **Shared UI** | Context / Zustand | Theme, sidebar state |
| **Form state** | React Hook Form | Complex forms |
| **URL state** | Router params | Filters, pagination |

```
┌─────────────────────────────────────────────────────────────┐
│                    State Decision Tree                       │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Is it server data?                                          │
│  ├─ YES → React Query / SWR                                 │
│  └─ NO → Is it shared across components?                    │
│          ├─ YES → Context / Zustand                         │
│          └─ NO → Is it a form?                              │
│                  ├─ YES → React Hook Form                   │
│                  └─ NO → useState                           │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## Server State (React Query)

### Basic Query

```typescript
import { useQuery } from '@tanstack/react-query'

export function useUser(userId: string) {
  return useQuery({
    queryKey: ['user', userId],
    queryFn: () => api.getUser(userId),
    staleTime: 5 * 60 * 1000, // 5 minutes
  })
}

// Usage
function UserProfile({ userId }: { userId: string }) {
  const { data: user, isLoading, error } = useUser(userId)
  
  if (isLoading) return <Skeleton />
  if (error) return <Error message={error.message} />
  
  return <Profile user={user} />
}
```

### Query with Options

```typescript
export function useUsers(filters: UserFilters) {
  return useQuery({
    queryKey: ['users', filters],
    queryFn: () => api.getUsers(filters),
    staleTime: 60 * 1000,
    placeholderData: previousData => previousData,
    enabled: !!filters.status, // Conditional fetching
  })
}
```

### Mutations

```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query'

export function useUpdateUser() {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: (data: UpdateUserData) => api.updateUser(data),
    onSuccess: (data, variables) => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: ['user', variables.id] })
      queryClient.invalidateQueries({ queryKey: ['users'] })
    },
    onError: (error) => {
      toast.error('Failed to update user')
    },
  })
}

// Usage
function EditUserForm({ user }: { user: User }) {
  const updateUser = useUpdateUser()
  
  const handleSubmit = (data: FormData) => {
    updateUser.mutate({ id: user.id, ...data })
  }
  
  return (
    <form onSubmit={handleSubmit}>
      {/* form fields */}
      <button disabled={updateUser.isPending}>
        {updateUser.isPending ? 'Saving...' : 'Save'}
      </button>
    </form>
  )
}
```

### Optimistic Updates

```typescript
export function useToggleFavorite() {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: toggleFavorite,
    onMutate: async (itemId) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['items'] })
      
      // Snapshot previous value
      const previousItems = queryClient.getQueryData(['items'])
      
      // Optimistically update
      queryClient.setQueryData(['items'], (old: Item[]) =>
        old.map(item =>
          item.id === itemId
            ? { ...item, isFavorite: !item.isFavorite }
            : item
        )
      )
      
      return { previousItems }
    },
    onError: (err, itemId, context) => {
      // Rollback on error
      queryClient.setQueryData(['items'], context?.previousItems)
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['items'] })
    },
  })
}
```

---

## Local State (useState)

### Simple State

```typescript
function SearchInput() {
  const [query, setQuery] = useState('')
  
  return (
    <input
      value={query}
      onChange={(e) => setQuery(e.target.value)}
    />
  )
}
```

### Complex State

```typescript
interface FilterState {
  search: string
  status: 'all' | 'active' | 'inactive'
  sortBy: 'name' | 'date'
}

function useFilters(initial: FilterState) {
  const [filters, setFilters] = useState(initial)
  
  const updateFilter = <K extends keyof FilterState>(
    key: K,
    value: FilterState[K]
  ) => {
    setFilters(prev => ({ ...prev, [key]: value }))
  }
  
  const resetFilters = () => setFilters(initial)
  
  return { filters, updateFilter, resetFilters }
}
```

---

## Shared State (Context)

### Theme Context Example

```typescript
// contexts/theme.tsx
interface ThemeContextValue {
  theme: 'light' | 'dark'
  toggleTheme: () => void
}

const ThemeContext = createContext<ThemeContextValue | null>(null)

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<'light' | 'dark'>('light')
  
  const toggleTheme = useCallback(() => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light')
  }, [])
  
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  )
}

export function useTheme() {
  const context = useContext(ThemeContext)
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider')
  }
  return context
}
```

### When to Use Context

✅ Good for:
- Theme/appearance settings
- Auth state (current user)
- Feature flags
- Locale/i18n

❌ Avoid for:
- Frequently updating data (causes re-renders)
- Server state (use React Query)
- Complex state logic (use Zustand/Redux)

---

## Form State (React Hook Form)

### Basic Form

```typescript
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'

const schema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
})

type FormData = z.infer<typeof schema>

function LoginForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<FormData>({
    resolver: zodResolver(schema),
  })
  
  const onSubmit = async (data: FormData) => {
    await login(data)
  }
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('email')} />
      {errors.email && <span>{errors.email.message}</span>}
      
      <input type="password" {...register('password')} />
      {errors.password && <span>{errors.password.message}</span>}
      
      <button disabled={isSubmitting}>
        {isSubmitting ? 'Logging in...' : 'Login'}
      </button>
    </form>
  )
}
```

---

## URL State

### Query Parameters

```typescript
import { useSearchParams } from 'next/navigation'

function FilteredList() {
  const searchParams = useSearchParams()
  const router = useRouter()
  
  const status = searchParams.get('status') ?? 'all'
  const page = parseInt(searchParams.get('page') ?? '1')
  
  const updateParams = (updates: Record<string, string>) => {
    const params = new URLSearchParams(searchParams)
    Object.entries(updates).forEach(([key, value]) => {
      params.set(key, value)
    })
    router.push(`?${params.toString()}`)
  }
  
  return (
    <>
      <StatusFilter
        value={status}
        onChange={(v) => updateParams({ status: v, page: '1' })}
      />
      <Pagination
        page={page}
        onChange={(p) => updateParams({ page: String(p) })}
      />
    </>
  )
}
```

---

## Caching Strategies

### Query Key Conventions

```typescript
// Hierarchical keys for proper invalidation
const queryKeys = {
  users: {
    all: ['users'] as const,
    lists: () => [...queryKeys.users.all, 'list'] as const,
    list: (filters: Filters) => [...queryKeys.users.lists(), filters] as const,
    details: () => [...queryKeys.users.all, 'detail'] as const,
    detail: (id: string) => [...queryKeys.users.details(), id] as const,
  },
}

// Usage
useQuery({ queryKey: queryKeys.users.detail(userId) })

// Invalidation
queryClient.invalidateQueries({ queryKey: queryKeys.users.all })
```

### Stale Time Guidelines

| Data Type | Stale Time | Rationale |
|-----------|------------|-----------|
| User profile | 5 min | Rarely changes |
| List data | 1 min | May be modified |
| Real-time data | 0 | Always fresh |
| Static data | Infinity | Never refetch |

---

## Anti-Patterns

### What to Avoid

```typescript
// ❌ Storing server data in useState
const [users, setUsers] = useState([])
useEffect(() => {
  fetchUsers().then(setUsers)
}, [])

// ✅ Use React Query
const { data: users } = useQuery({
  queryKey: ['users'],
  queryFn: fetchUsers,
})

// ❌ Prop drilling through many levels
<App user={user}>
  <Layout user={user}>
    <Sidebar user={user}>
      <UserMenu user={user} />

// ✅ Use context for widely-shared state
<UserProvider>
  <App />
</UserProvider>

// ❌ Putting everything in global state
const store = {
  modalOpen: false,
  formData: {},
  users: [],
  // ...
}

// ✅ Colocate state where it's used
// Local UI state → useState
// Server data → React Query
// Shared app state → Context/Zustand
```

---

## Related Rules

- `project-architecture.mdc` - File structure
- `coding-patterns.mdc` - Code conventions
- `testing-strategy.mdc` - Testing state
